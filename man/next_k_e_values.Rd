% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/evalues.R
\name{next_k_e_values}
\alias{next_k_e_values}
\title{E-value}
\usage{
next_k_e_values(
  e.value.run.before,
  new.y,
  new.crps.F.para,
  new.crps.G.para,
  idx = 2
)
}
\arguments{
\item{e.value.run.before}{is the result of the run of \code{\link{e_value}}.}

\item{new.y}{oberservations y in R^k, is the new observation to evaluate}

\item{new.crps.F.para}{of the form \code{list("mu" = mu[k], "sd" = NA)} or of the form
\code{list("points.cdf" = tibble::tibble with points and cdfs)}, if either "mu" or "sd" are a single value, set it to NA.
For mixnorm, put the new row of mu,sd and w as input, see examples.}

\item{new.crps.G.para}{of the form \code{list("mu" = mu[k], "sd" = NA)} or of the form
\code{list("points.cdf" = tibble::tibble with points and cdfs)}, if either "mu" or "sd" are a single value, set it to NA.
For mixnorm, put the new row of mu,sd and w as input, see examples.}

\item{idx}{= 2, this is an aditional parameter to idex the run of this call}
}
\value{
Returns a list containing the input values and the calculated e-values.
}
\description{
This method prepares the information of the old run from \code{\link{e_value}} to be run again and runs it with some additional input.
With this approach, all the infimums, do not have to be calculated for each k, but only for the new ones and also for the betting
approach, not the whole matrices have to be calculated again. This procedure reduces the computational cost massively.
}
\examples{
mu <- stats::rnorm(10)
y <- stats::rnorm(10, mu)
result <- e_value(y = y, crps.F.para = list("mu" = mu, "sd" = 1), crps.G.para = list("mu" = 0, "sd" = 2))
new.mu <- stats::rnorm(1)
next_k_e_values(result, new.y = stats::rnorm(1, new.mu), new.crps.F.para = list("mu" = new.mu, "sd" = NA), new.crps.G.para = list("mu" = NA, "sd" = NA))

mu <- stats::rnorm(10)
tau <- sample(c(-1, 1), 10, replace = TRUE)
result.next.k.clim.mixnorm.first <- e_value(rnorm(10), forecast_input(mu = 0, sd = 1), forecast_input(mu = cbind(mu, mu + tau), sd = matrix(nrow = 10, ncol = 2, 1), w = matrix(nrow = 10, ncol = 2, 1 / 2)), method = c("alt-cons","GRAPA", "lambda", "alt-conf", "alt-more-cons"), p.value.method = "t")
new.mu <- stats::rnorm(1)
new.tau <- sample(c(-1, 1), 1)
result.next.k.clim.mixnorm <- next_k_e_values(result.next.k.clim.mixnorm.first, new.y = stats::rnorm(1, new.mu), new.crps.F.para = list("mu" = NA, "sd" = NA), new.crps.G.para = list("mu" = c(new.mu, new.mu + new.tau), "sd" = c(1,1), "w" = c(1/2, 1/2)))

}
\seealso{
\code{\link{e_value}}
}
